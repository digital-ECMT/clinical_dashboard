---
title: "Clinical dashboard"
author: "dECMT"
date: "`r Sys.Date()`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
runtime: shiny
---

```{r setup, include=FALSE}
require(flexdashboard)
require(dplyr)
require(tidyr)
require(kableExtra)
require(stringr)
#require(DT)
#require(kableExtra)
#require(cgdsr)
#require(formattable)
require(ggplot2)
require(reshape2)
require(survival)
#require(survminer)
require(ggfortify)
require(gganimate)
require(av)
require(shinyWidgets)
require(lubridate)


## clean up
rm(list=ls())

##create a custom palette based on palette used for dECMT slide template
dECMTpalette <- c(rgb(red=0, green=137, blue=174, maxColorValue = 255), 
                  rgb(red=208, green=134, blue=146, maxColorValue = 255),
                  rgb(red=237, green=154, blue=75, maxColorValue = 255),
                  rgb(red=174, green=190, blue=6, maxColorValue = 255),
                  rgb(red=0, green=105, blue=145, maxColorValue = 255), 
                  rgb(red=197, green=74, blue=117, maxColorValue = 255),
                  rgb(red=229, green=113, blue=67, maxColorValue = 255),
                  rgb(red=119, green=167, blue=40, maxColorValue = 255),
                  rgb(red=113, green=121, blue=126, maxColorValue = 255),
                  rgb(red=0, green=0, blue=0, maxColorValue = 255),
                  rgb(red=242, green=222, blue=3, maxColorValue = 255),
                  rgb(red=146, green=68, blue=168, maxColorValue = 255),
                  rgb(red=108, green=200, blue=93, maxColorValue = 255),
                  rgb(red=254, green=240, blue=0, maxColorValue = 255),
                  rgb(red=105, green=25, blue=122, maxColorValue = 255),
                  rgb(red=35, green=99, blue=32, maxColorValue = 255))


```
  
  
```{r read and process demographics, warning=FALSE}
demographics <- read.csv(file = paste0(getwd(), "/DEMOGRAPHICS.csv"), stringsAsFactors = FALSE, header = TRUE, na.strings = "NA")

## drop any rows with missing values
demographics <- demographics[complete.cases(demographics), ]

## drop any redundant rows
demographics <- unique(demographics)

## detect variable type... 
demographics$VARIABLE_TYPE <- NA
## first try and convert to numeric (anything other than number gives NA)
demographics$VARIABLE_TYPE[!is.na(as.numeric(demographics$VARIABLE_VALUE))] <- "NUMERIC"
## try and parse to date  
demographics$VARIABLE_TYPE[!is.na(lubridate::ymd(demographics$VARIABLE_VALUE))] <- "DATE"
## try and convert to logical
demographics$VARIABLE_TYPE[!is.na(as.logical(demographics$VARIABLE_VALUE))] <- "LOGICAL"
## if none of the above, assume character
demographics$VARIABLE_TYPE[is.na(demographics$VARIABLE_TYPE)] <- "CHARACTER"



## cast to wide format 
demographics_wide <- reshape2::dcast(data = demographics, formula = SUBJECT_ID ~ VARIABLE_NAME, value.var = "VARIABLE_VALUE")
demographics_wide$DOB <- lubridate::ymd(demographics_wide$DOB)

## loop through each column in demographics wide table and format according to corresponding VARIABLE_TYPE value... 
for(i in 2:ncol(demographics_wide)) {
  column_name = names(demographics_wide)[i]
  column_type = unique(demographics$VARIABLE_TYPE[demographics$VARIABLE_NAME == column_name])

  if(column_type == "DATE") {
    demographics_wide[ , i] <- lubridate::ymd(demographics_wide[ , i])
    next
  }
  if(column_type == "NUMERIC") {
    demographics_wide[ , i] <- as.numeric(demographics_wide[ , i])
    next
  }
  
  else {demographics_wide[ , i] <- factor(demographics_wide[ , i])
    next}
}


```
   
```{r read and process events, warning=FALSE}
events <- read.csv(file = paste0(getwd(), "/EVENTS.csv"), stringsAsFactors = FALSE, header = TRUE, na.strings = "NA")

## drop any rows with missing values
events <- events[complete.cases(events), ]

## drop any redundant rows
events <- unique(events)

## convert EVENT_DATETIME to datetime format
events$EVENT_DATETIME <- lubridate::as_datetime(events$EVENT_DATETIME)

## cast to wide format 
# as there may be >1 of a given event type, just get the event witht the earliest datetime value
events_wide <- events %>%
  group_by(SUBJECT_ID, EVENT_NAME) %>%
  arrange(EVENT_DATETIME) %>%
  slice_head(n = 1) %>%         ## just keep first of each event type
  arrange(SUBJECT_ID, EVENT_DATETIME) %>%       ## reorder again so when cast wide, columns are in chronological order
  as.data.frame() 



## work out the factor order for different event types (so we can reorder columns later when we cast to wide)
event_order <- events_wide %>%
    group_by(EVENT_NAME) %>%
    summarise(
        mean_datetime = mean(EVENT_DATETIME)
    ) %>%
    arrange(mean_datetime) %>%
    as.data.frame()

# cast wide
events_wide <- reshape2::dcast(data = events_wide, formula = SUBJECT_ID ~ factor(EVENT_NAME, levels = event_order$EVENT_NAME), value.var = "EVENT_DATETIME")

# convert the wide columns to date format
## for simplicity in wide version, we will just use date, not datetime
## loop through each column in demographics wide table and format according to corresponding VARIABLE_TYPE value...
for(i in 2:ncol(events_wide)) {
    events_wide[ , i] <- lubridate::as_datetime(events_wide[ , i])  ## convert to datetime first
    events_wide[ , i] <- lubridate::as_date(events_wide[ , i])  ## then just keep the date
}


```
  
```{r join demographics_wide to events_wide}
demographics_wide <- merge(x=demographics_wide, by.x = "SUBJECT_ID", all.x = TRUE, y=events_wide, by.y = "SUBJECT_ID", all.y = FALSE)

```

   
```{r read and process measurements, warning=FALSE}
measurements <- read.csv(file = paste0(getwd(), "/MEASUREMENTS.csv"), stringsAsFactors = FALSE, header = TRUE, na.strings = "NA")

## drop any rows with missing values
measurements <- measurements[!is.na(measurements$MEASUREMENT_VALUE), ]

## drop any redundant rows
measurements <- unique(measurements)

## convert MEASUREMENT_DATETIME to datetime format
measurements$MEASUREMENT_DATETIME <- lubridate::as_datetime(measurements$MEASUREMENT_DATETIME)

measurements$VARIABLE_TYPE <- NA
for(i in 1:length(unique(measurements$MEASUREMENT_NAME))) {
  measurement_name <- unique(measurements$MEASUREMENT_NAME)[i]
  values <- unique(measurements$MEASUREMENT_VALUE[measurements$MEASUREMENT_NAME == measurement_name])
  ## test for logical first, since 0 and 1 can be numeric, but likely to be logical if no other numbers
  if(length(setdiff(values, c(0,1)))==0) {
    measurements$VARIABLE_TYPE[measurements$MEASUREMENT_NAME == measurement_name] <- "LOGICAL"
    next
  }
  if(!anyNA(as.logical(values))) {
    measurements$VARIABLE_TYPE[measurements$MEASUREMENT_NAME == measurement_name] <- "LOGICAL"
    next
  }
  # if(!anyNA(as.logical(as.numeric(values)))) {
  #   measurements$VARIABLE_TYPE[measurements$MEASUREMENT_NAME == measurement_name] <- "LOGICAL"
  #   next
  # }
  ## test for numeric
  if(!anyNA(as.numeric(values))) {
    measurements$VARIABLE_TYPE[measurements$MEASUREMENT_NAME == measurement_name] <- "NUMERIC"
    next
  } else {
    ## else assume type is character
    measurements$VARIABLE_TYPE[measurements$MEASUREMENT_NAME == measurement_name] <- "CHARACTER"
  }
  
}



```
  
  
  
Row {.tabset}
-----------------------------------------------------------------------  
   
### Population  
  


```{r reactive demographics table}

# create table with filters
output$populationTable = DT::renderDT(demographics_wide,
             filter = "top",
             options = list(pageLength = 5, autoWidth = TRUE)
        )


# render table
DT::dataTableOutput('populationTable')

# Reactive function to which rows are selected
sel <- reactive({ 
    input$populationTable_rows_all
})

# reactive function to hold IDs of patients in filtered list
selected_patients <- reactive({
  indices <- input$populationTable_rows_all
  subject_ids <- demographics_wide$SUBJECT_ID[indices]
  print(subject_ids)
  return(subject_ids)
})
renderText(selected_patients())




  
```

### Lab tests  
  
```{r create labtests heatmap}

# make palette a named vector, with names matching factor levels, in order to control which color gets matched to what
pal <- c("HIGH" = "red","NORMAL" = "green", "LOW" = "blue")

## create a reactive slider that will amend min, max, range based on selected parameter
output$normal_range_slider <- renderUI({
   sliderInput("normal_range", 
               label = "Normal range:", 
               min = min(as.numeric(measurements$MEASUREMENT_VALUE[measurements$MEASUREMENT_NAME=="UREA"])),
               max = max(as.numeric(measurements$MEASUREMENT_VALUE[measurements$MEASUREMENT_NAME=="UREA"])),
               value = c(min(as.numeric(measurements$MEASUREMENT_VALUE[measurements$MEASUREMENT_NAME=="UREA"])),
                         max(max(as.numeric(measurements$MEASUREMENT_VALUE[measurements$MEASUREMENT_NAME=="UREA"]))))
   )

  })

## create plot
measurements_heatmap <- reactive({
   measurements %>%
    dplyr::filter(MEASUREMENT_NAME == "UREA") %>%
    ggplot(aes(x=SUBJECT_ID, y=MEASUREMENT_DATETIME, color=as.numeric(MEASUREMENT_VALUE))) +
    geom_tile() +
    coord_flip()
})

output$heatmap_plot <- renderPlot({
  measurements_heatmap()
})

## display on page
fillCol(height = 600, flex = c(NA, 1),
  inputPanel(
    # selectInput(inputId = "labsBaseline", label="Select x-axis:", choices = labtest.baselines, selected = labtest.baselines[1], multiple = FALSE,  selectize = TRUE, width = NULL, size = NULL),
    # selectInput(inputId = "labsParameter", label="Select y-axis:", choices = labtests, selected = labtests[12], multiple = FALSE,  selectize = TRUE, width = NULL, size = NULL),
    # selectInput(inputId = "labsStratifier", label="Select stratifier:", choices = labtest.stratifiers, selected = labtest.stratifiers[1], multiple = FALSE,  selectize = TRUE, width = NULL, size = NULL),
    uiOutput("normal_range_slider") ## display the reactive slider

    ),
  plotOutput("heatmap_plot", height = "100%")
)







# ## set NEUTROPHILS as default value
# labtest.baselines <- names(dplyr::select(LabResults_daily, -c("STUDY_ID", "PARAMETER", "LOWER_RANGE", "UPPER_RANGE", "DATE", "meanValue", "category")))
# #selected.labtest.baseline <- labtest.baselines[1]
# labtest.stratifiers <- c("FINAL_OUTCOME", "VENTILATED", "ADMITTED_ITU", "PRESENTATION")
# #selected.labtest.stratifier <- labtest.stratifiers[2]
# 
# ## create a reactive slider that will amend min, max, range based on selected parameter
# output$normal.range.slider <- renderUI({
#    sliderInput("normal.range", label = "Normal range:", min = normal.ranges[normal.ranges$PARAMETER==input$labsParameter, "MIN.VALUE"], max = normal.ranges[normal.ranges$PARAMETER==input$labsParameter, "MAX.VALUE"], 
#     value = c(normal.ranges[normal.ranges$PARAMETER==input$labsParameter, "LLN"],normal.ranges[normal.ranges$PARAMETER==input$labsParameter, "ULN"]))
# 
#   })



# fillCol(height = 600, flex = c(NA, 1), 
#   inputPanel(
#     selectInput(inputId = "labsBaseline", label="Select x-axis:", choices = labtest.baselines, selected = labtest.baselines[1], multiple = FALSE,  selectize = TRUE, width = NULL, size = NULL), 
#     selectInput(inputId = "labsParameter", label="Select y-axis:", choices = labtests, selected = labtests[12], multiple = FALSE,  selectize = TRUE, width = NULL, size = NULL), 
#     selectInput(inputId = "labsStratifier", label="Select stratifier:", choices = labtest.stratifiers, selected = labtest.stratifiers[1], multiple = FALSE,  selectize = TRUE, width = NULL, size = NULL), 
#     uiOutput("normal.range.slider") ## display the reactive slider
# 
#     ),
#   plotOutput("labsPlot", height = "100%")
# )



   
# reactiveLabsPlot <- reactive({
#    labTestHM <- merge(x=reactiveDemographics(), by.x = "STUDY_ID", y=LabResults_daily, by.y = "STUDY_ID")
#    ## specify factor order category
#    #labTestHM$category <- factor(labTestHM$category, levels = c("LOW", "NORMAL", "HIGH"))
#    selected.labtest.stratifier <- input$labsStratifier
#    selectedLabs <- input$labsParameter
#    labTestHM <- filter(labTestHM, PARAMETER==selectedLabs)
#    
#    # Adding limits to scale_fill_manual ensures that all the levels will appear in the legend, even if they don't all appear in the data.
#    
#    ## reset values for category based on selected range on slider
#    labTestHM$category <- ifelse(labTestHM$meanValue > input$normal.range[2], "HIGH",ifelse(labTestHM$meanValue<input$normal.range[1], "LOW", "NORMAL"))
#    
#    
#    
#    ## specify factor order category
#    labTestHM$category <- factor(labTestHM$category, levels = c("LOW", "NORMAL", "HIGH"))
#    selected.labtest.baseline <- input$labsBaseline
#    xvar <- labTestHM[ , selected.labtest.baseline]
#    ggplot(data=labTestHM, aes(x=xvar, y=STUDY_ID, fill= category)) +
#     geom_tile() +
#     scale_fill_manual(values = pal,limits=names(pal)) +
#     # scale_fill_identity(guide = "legend", labels = levels(droplevels(as.factor(labTestHM$category)))) +
#     facet_grid( labTestHM[ ,selected.labtest.stratifier] ~., scales="free_y", space = "free_y") +
#     theme(plot.title = element_text(size=12, face="bold", hjust=0.5),
#           axis.text.y=element_blank(),
#           panel.border = element_rect(color = "black", fill = NA, size = 0.5),
#           strip.background = element_rect(color = "black", size = 0.5),
#           strip.text.y =  element_text(angle=0)) +
#     labs(title = paste0("Changes in daily mean\n", selectedLabs, " since baseline"), x=paste0(selected.labtest.baseline, ", (days)"), y = "Patient", fill = selectedLabs) +
#       
#     coord_cartesian(xlim = c(-7, 50))
# })
# 
# # renderPlot( {
# #     reactiveLabsPlot()
# # })
# output$labsPlot <- renderPlot({
#   reactiveLabsPlot()
# })

```
   
   
   
   
   
   
   